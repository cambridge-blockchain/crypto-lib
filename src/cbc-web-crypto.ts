import { Config } from './config';
import { Converter } from './converter';
import { Hash } from './models/hash';

import { Observable, from } from 'rxjs';
import { flatMap, map } from 'rxjs/operators';

import { isEmpty } from 'lodash';
import { EncryptedData } from './models/encrypted_data';

export class CBCWebCrypto {
    private subtleCrypto: SubtleCrypto;
    private keyPairPromise: PromiseLike<CryptoKeyPair>;

    constructor() {
        this.subtleCrypto = crypto.subtle;
        this.keyPairPromise = this.subtleCrypto.generateKey(Config.RSA_KEY_FORMAT, false, ['decrypt']);
    }

    publicKeyBase64(): Observable<string> {
        return from(this.keyPairPromise).pipe(
            flatMap(
                (handle: CryptoKeyPair): Observable<ArrayBuffer> => {
                    return from(this.subtleCrypto.exportKey('spki', handle.publicKey));
                },
            ),
            map((publicKey: ArrayBuffer): string => {
                const body = btoa(String.fromCharCode.apply(null, new Uint8Array(publicKey)));
                return btoa(`-----BEGIN PUBLIC KEY-----\n${body}\n-----END PUBLIC KEY-----`);
            }),
        );
    }

    // encryptAttribute takes an attribute value and an encrypted symmetric key (with the keypair generated by this object)
    // as input and returns the encrypted attribute with a randomly generate IV. The attribute value is encrypted with
    // the plaintext symmetric key (decrypted encSymKey).
    async encryptAttribute(attributeValue: ArrayBuffer, encSymKey: string): Promise<EncryptedData> {
        if (isEmpty(encSymKey)) {
            return;
        }
        const keyPair = await this.keyPairPromise;
        const privKey = keyPair.privateKey;

        const keyData = Converter.HexToArrayBuffer(encSymKey);
        const plainTextSymKeyData = await this.subtleCrypto.decrypt(Config.RSA_TYPE_PARAM, privKey, keyData);
        const symKeyHandle = await this.subtleCrypto.importKey('raw', plainTextSymKeyData, 'AES-GCM', true, [
            'encrypt',
        ]);

        const aesConfig = Config.generateAESKeyFormat();
        const encData = await this.subtleCrypto.encrypt(aesConfig, symKeyHandle, attributeValue);

        const returnValue = new EncryptedData();
        returnValue.encData = encData;
        returnValue.iv = aesConfig.iv;

        return returnValue;
    }

    // decryptAttribute takes an encrypted attribute value and encrypted symmetric key (with the keypair generate by this object)
    // and returns the plaintext attribute value. The attribute value is decrypted with the plaintext symmetric key (decrypted encSymKey)
    async decryptAttribute(encAttributeValue: ArrayBuffer, encSymKey: string, iv: Uint8Array): Promise<ArrayBuffer> {
        if (isEmpty(encSymKey)) {
            return;
        }
        const keyPair = await this.keyPairPromise;
        const privKey = keyPair.privateKey;

        const keyData = Converter.HexToArrayBuffer(encSymKey);
        const plainTextSymKeyData = await this.subtleCrypto.decrypt(Config.RSA_TYPE_PARAM, privKey, keyData);
        const symKeyHandle = await this.subtleCrypto.importKey('raw', plainTextSymKeyData, 'AES-GCM', true, [
            'decrypt',
        ]);

        const aesConfig = Config.generateAESKeyFormat();
        aesConfig.iv = iv;

        return await this.subtleCrypto.decrypt(aesConfig, symKeyHandle, encAttributeValue);
    }

    async decryptStringAttribute(encAttributeValue: string, encSymKey: string, iv: Uint8Array): Promise<ArrayBuffer> {
        const encAttribute = Converter.StringToUint8Array(encAttributeValue);
        return this.decryptAttribute(encAttribute, encSymKey, iv);
    }

    async computeHash(attributeValue: ArrayBuffer): Promise<Hash> {
        const key = await this.subtleCrypto.generateKey(
            {
                name: 'HMAC',
                hash: { name: 'SHA-384' },
            },
            true,
            ['sign'],
        );

        const rawKey = await this.subtleCrypto.exportKey('raw', key);
        const encodedKey = btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey)));

        // const enc = new TextEncoder();
        // const encoded = enc.encode(attributeValue);
        const signature = await this.subtleCrypto.sign('HMAC', key, attributeValue);

        const encodedSignature = btoa(String.fromCharCode.apply(null, new Uint8Array(signature)));

        const hash = new Hash();
        hash.hash = encodedSignature;
        hash.salt = encodedKey;
        return hash;
    }

    // verifyHash returns true (in a Promise) if the attributeValue computes the same salted has as provided
    async verifyHash(hash: Hash, attributeValue: ArrayBuffer): Promise<boolean> {
        // const enc = new TextEncoder();
        // const encoded = enc.encode(attributeValue);

        const signature = Uint8Array.from(atob(hash.hash), (c) => c.charCodeAt(0));
        const decodedKey = Uint8Array.from(atob(hash.salt), (c) => c.charCodeAt(0));

        const key = await this.subtleCrypto.importKey(
            'raw',
            decodedKey,
            {
                name: 'HMAC',
                hash: { name: 'SHA-384' },
            },
            false,
            ['verify'],
        );

        const result = await this.subtleCrypto.verify('HMAC', key, signature, attributeValue);
        return result;
    }
}
